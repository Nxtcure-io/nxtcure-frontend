from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import re
import io
import sqlite3
from pathlib import Path
from typing import List, Dict, Optional
from PIL import Image
import torch
from transformers import TrOCRProcessor, VisionEncoderDecoderModel
import logging

app = FastAPI(
    title="Clinical OCR Service",
    description="API for extracting clinical information from handwritten notes with PII redaction",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

MODEL_ID = "microsoft/trocr-base-handwritten"
device = "cuda" if torch.cuda.is_available() else "cpu"

try:
    processor = TrOCRProcessor.from_pretrained(MODEL_ID)
    model = VisionEncoderDecoderModel.from_pretrained(MODEL_ID).to(device)
    model.eval()
    logger.info(f"Model loaded successfully on device: {device}")
except Exception as e:
    logger.error(f"Failed to load model: {str(e)}")
    raise RuntimeError("Failed to initialize OCR model")

to_redact = [
    # Names 
    r"\b([A-Z][a-z\'\-]+\,\s[A-Z][a-z\'\-]+)\b",  # Last, First
    r"\b([A-Z][a-z\'\-]+(?:\s[A-Z][a-z\'\-\.]+){1,3})\b",  # First M. Last
    
    # Addresses
    r"\b\d{1,5}\s[\w\s]+\s(?:Street|St|Avenue|Ave|Road|Rd|Lane|Ln|Boulevard|Blvd|Drive|Dr)\b",
    r"\bP\.?O\.?\sBox\s\d+\b",
    
    # Identifiers
    r"\b\d{3}[-\.\s]?\d{2}[-\.\s]?\d{4}\b",            # SSN
    r"\b\d{3}[-\.\s]?\d{3}[-\.\s]?\d{4}\b",            # Phone
    r"\b[\w\.-]+@[\w\.-]+\.\w+\b",                     # Email
    
    # Dates 
    r"\b(?:\d{1,2}[/\-]\d{1,2}[/\-]\d{2,4}|\d{4}[/\-]\d{1,2}[/\-]\d{1,2})\b",
    r"(Date of Birth|DOB)\s*[:\-]\s*(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s\d{1,2},?\s\d{4}",
    
]

clinical_patterns = {
    "medications": r"(?i)Medications?(?:\s*[:\-]\s*|\s+)(.*?)(?=\n\n|\n\w|$)",
    "diagnoses": r"(?i)(?:Dx|Diagnosis|Diagnoses)(?:\s*[:\-]\s*|\s+)(.*?)(?=\n\n|\n\w|$)",
    "allergies": r"(?i)Allerg(?:y|ies)(?:\s*[:\-]\s*|\s+)(.*?)(?=\n\n|\n\w|$)",
    "vitals": r"(?i)(BP|HR|Pulse|Temp|Blood Pressure|Heart Rate|Temperature)[\s:]*([\d\/]+)",
    "age": r"(?i)Age(?:\s*[:\-]\s*|\s+)(\d{1,3})",
    "sex": r"(?i)Sex(?:\s*[:\-]\s*|\s+)(Male|Female|M|F|Intersex|X",
}

redact_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in to_redact]
clinical_patterns = {k: re.compile(v, re.IGNORECASE) for k, v in clinical_patterns.items()}

def strip(text: str) -> str:
    clean = text
    for pat in redact_patterns:
        clean = pat.sub("[REDACTED]", clean)
    return clean

def extract_clinical_facts(text: str) -> Dict[str, List[str]]:
    facts = {k: [] for k in clinical_patterns}
    for line in text.splitlines():
        for key, pat in clinical_patterns.items():
            m = re.search(pat, line, flags=re.IGNORECASE)
            if m:
                facts[key].append(m.group(1).strip())
    return facts

def prompt_missing_facts(facts: Dict[str, List[str]]) -> Dict[str, List[str]]:
    for pattern in facts - clinical_patterns:
        facts[pattern] = [input(f"Please enter any {pattern}: ")]
    return facts

DB_PATH = Path("clinical_data.db")
DDL = """
CREATE TABLE IF NOT EXISTS clinical_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    source_filename TEXT,
    medications TEXT,
    diagnoses TEXT,
    allergies TEXT,
    vitals TEXT
);
"""

def init_db():
    try:
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute(DDL)
        logger.info("Database initialized successfully")
    except Exception as e:
        logger.error(f"Database initialization failed: {str(e)}")
        raise

def save_record(fname: str, facts: Dict[str, List[str]]):
    """Save extracted clinical facts to database"""
    try:
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute(
                """
                INSERT INTO clinical_records
                    (source_filename, medications, diagnoses, allergies, vitals)
                VALUES (?,?,?,?,?)
                """,
                (
                    fname,
                    "; ".join(facts["medications"]),
                    "; ".join(facts["diagnoses"]),
                    "; ".join(facts["allergies"]),
                    "; ".join(facts["vitals"]),
                    "; ".join(facts["age"]),
                    "; ".join(facts["sex"]),
                ),
            )
            conn.commit()
        logger.info(f"Record saved for file: {fname}")
    except Exception as e:
        logger.error(f"Failed to save record: {str(e)}")
        raise

def ocr_image(img: Image.Image) -> str:
    """Perform OCR on image using TrOCR model"""
    try:
        pixel_values = processor(images=img, return_tensors="pt").pixel_values.to(device)
        with torch.no_grad():
            generated_ids = model.generate(pixel_values)
        return processor.batch_decode(generated_ids, skip_special_tokens=True)[0]
    except Exception as e:
        logger.error(f"OCR failed: {str(e)}")
        raise HTTPException(status_code=500, detail="OCR processing failed")
    
init_db()

@app.post("/upload/", response_model=dict)
async def upload_record(file: UploadFile = File(...)):
    try:
        img = Image.open(io.BytesIO(await file.read())).convert("RGB")
    except Exception:
        raise Exception(status_code=400, detail="Unsupported file type")

    raw_text  = ocr_image(img)
    safe_text = strip(raw_text)
    facts = prompt_missing_facts(extract_clinical_facts(safe_text))
    save_record(file.filename, facts)
    return {
        "filename": file.filename,
        "extracted_facts": facts,
        "note": "Your personal data has been stripped; raw text never saved."
    }


